# Ch.4 Tools + Tool Calling Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 在 Ch.3 StateGraph 基础上叠加工具调用能力——注册 calculator 和 filesystem MCP 工具，用 `ToolNode` + `tools_condition` 实现 ReAct 循环，MCP 异步懒加载。

**Architecture:** `stream_agent` 首次调用时异步初始化工具列表（calculator + MCP filesystem）并编译图，之后缓存。图拓扑：`START → chat → tools_condition → tools → chat`（循环）/ `→ END`。`ToolNode` 和 `tools_condition` 来自 `langgraph.prebuilt`，无需手写 should_continue。

**Tech Stack:** Python, `langchain-mcp-adapters`, `langgraph.prebuilt.ToolNode`, `langgraph.prebuilt.tools_condition`, `asyncio.Lock`（双重检查懒加载）

---

## Task 1: 安装依赖

**Files:**
- Modify: `backend/pyproject.toml`（由 uv 自动更新）

**Step 1: 安装 langchain-mcp-adapters**

```bash
cd backend && uv add langchain-mcp-adapters
```

Expected: `pyproject.toml` 和 `uv.lock` 更新，无报错。

**Step 2: 验证导入**

```bash
uv run python -c "from langchain_mcp_adapters.client import MultiServerMCPClient; print('OK')"
```

Expected: 输出 `OK`。

**Step 3: 提交**

```bash
git add backend/pyproject.toml backend/uv.lock
git commit -m "feat(backend/ch4): add langchain-mcp-adapters dependency"
```

---

## Task 2: 创建 `agent/tools.py`（calculator + MCP）

**Files:**
- Create: `backend/agent/tools.py`
- Create: `backend/tests/test_tools.py`

**Step 1: 写失败测试**

创建 `backend/tests/test_tools.py`：

```python
import pytest
from agent.tools import calculator


def test_calculator_basic_arithmetic():
    assert calculator.invoke({"expression": "2 + 2"}) == "4"


def test_calculator_power():
    assert calculator.invoke({"expression": "2 ** 10"}) == "1024"


def test_calculator_sqrt():
    assert calculator.invoke({"expression": "sqrt(16)"}) == "4.0"


def test_calculator_blocks_import():
    with pytest.raises(Exception):
        calculator.invoke({"expression": "__import__('os').getcwd()"})
```

**Step 2: 确认测试失败**

```bash
cd backend && uv run pytest tests/test_tools.py -v
```

Expected: `ModuleNotFoundError` 或 `ImportError`（`agent/tools.py` 不存在）。

**Step 3: 实现 `agent/tools.py`**

创建 `backend/agent/tools.py`：

```python
import math
from langchain_core.tools import tool
from langchain_mcp_adapters.client import MultiServerMCPClient


@tool
def calculator(expression: str) -> str:
    """计算数学表达式，支持四则运算和 math 函数，如 '2 + 2'、'sqrt(16)'。"""
    safe_globals = {"__builtins__": {}, **vars(math)}
    return str(eval(expression, safe_globals))


async def get_all_tools() -> list:
    """获取所有工具：calculator + MCP filesystem 工具。"""
    client = MultiServerMCPClient(
        {
            "filesystem": {
                "transport": "stdio",
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"],
            }
        }
    )
    mcp_tools = await client.get_tools()
    return [calculator] + mcp_tools
```

**Step 4: 运行测试，确认通过**

```bash
cd backend && uv run pytest tests/test_tools.py -v
```

Expected: 4 个测试全部 PASS。

**Step 5: 提交**

```bash
git add backend/agent/tools.py backend/tests/test_tools.py
git commit -m "feat(backend/ch4): add calculator tool and MCP filesystem integration"
```

---

## Task 3: 重写 `agent/core.py`（懒加载 + ReAct 图）

**Files:**
- Modify: `backend/agent/core.py`

**Step 1: 写失败测试（验证图结构）**

追加到 `backend/tests/test_tools.py`：

```python
import asyncio
from agent.core import _get_graph


def test_graph_has_correct_nodes():
    """验证图懒加载后节点正确。"""
    # 绕过 MCP（注入假工具）
    import agent.core as core
    from agent.tools import calculator
    from langgraph.prebuilt import ToolNode, tools_condition
    from langgraph.graph import StateGraph, MessagesState, START, END
    from langgraph.checkpoint.memory import InMemorySaver

    tools = [calculator]
    llm_with_tools = core._llm.bind_tools(tools)

    def chat_node(state: MessagesState):
        return {"messages": [llm_with_tools.invoke(state["messages"])]}

    graph = (
        StateGraph(MessagesState)
        .add_node("chat", chat_node)
        .add_node("tools", ToolNode(tools))
        .add_edge(START, "chat")
        .add_conditional_edges("chat", tools_condition)
        .add_edge("tools", "chat")
        .compile(checkpointer=InMemorySaver())
    )
    assert "chat" in graph.nodes
    assert "tools" in graph.nodes
```

```bash
cd backend && uv run pytest tests/test_tools.py::test_graph_has_correct_nodes -v
```

Expected: PASS（图结构测试直接通过，因为用的是局部变量构建图）。

**Step 2: 实现新的 `agent/core.py`**

完整替换 `backend/agent/core.py`：

```python
# Ch.4: Tools + Tool Calling - 懒加载 ReAct 图（Ch.3 静态图无工具）
import asyncio
from typing import AsyncGenerator

from langchain_core.messages import HumanMessage
from langgraph.checkpoint.memory import InMemorySaver
from langgraph.graph import END, START, MessagesState, StateGraph
from langgraph.prebuilt import ToolNode, tools_condition
from providers.llm import get_llm

from agent.tools import get_all_tools

_llm = get_llm()
_checkpointer = InMemorySaver()
_graph = None
_lock = asyncio.Lock()


async def _get_graph():
    global _graph
    if _graph is None:
        async with _lock:
            if _graph is None:
                tools = await get_all_tools()
                llm_with_tools = _llm.bind_tools(tools)

                def chat_node(state: MessagesState):
                    return {"messages": [llm_with_tools.invoke(state["messages"])]}

                _graph = (
                    StateGraph(MessagesState)
                    .add_node("chat", chat_node)
                    .add_node("tools", ToolNode(tools))
                    .add_edge(START, "chat")
                    .add_conditional_edges("chat", tools_condition)
                    .add_edge("tools", "chat")
                    .compile(checkpointer=_checkpointer)
                )
    return _graph


async def stream_agent(message: str, thread_id: str = "default") -> AsyncGenerator[str, None]:
    graph = await _get_graph()
    config = {"configurable": {"thread_id": thread_id}}
    input_state = {"messages": [HumanMessage(content=message)]}
    async for chunk, _metadata in graph.astream(input_state, config=config, stream_mode="messages"):
        if chunk.content:
            yield chunk.content
```

**Step 3: 验证模块导入无误**

```bash
cd backend && uv run python -c "
import agent.core as c
import asyncio
print('imports OK, _graph is None:', c._graph is None)
print('_llm OK:', c._llm)
print('_checkpointer OK:', c._checkpointer)
"
```

Expected: 三行都输出预期值，无报错。

**Step 4: 提交**

```bash
git add backend/agent/core.py
git commit -m "feat(backend/ch4): ReAct loop with ToolNode + lazy async graph init"
```

---

## Task 4: 手动验收测试

> 注意：MCP 工具需要系统安装 Node.js/npx。

**Step 1: 验证 npx 可用**

```bash
npx --version
```

Expected: 打印版本号，如 `10.x.x`。若未安装 Node.js，参考 [nodejs.org](https://nodejs.org) 安装。

**Step 2: 启动后端**

```bash
cd backend && uv run uvicorn main:app --reload
```

Expected: 服务在 `http://localhost:8000` 启动，日志显示 `PonyAgent backend started`。

**Step 3: 发送计算器请求**

新开终端：

```bash
curl -sN -X POST http://localhost:8000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "2的10次方是多少？请用计算器工具计算。", "thread_id": "test-calc"}' \
  | head -20
```

Expected SSE 事件流中包含 `1024`，并且日志应该能看到 agent 调用了 calculator 工具（tool_calls 和 ToolMessage）。

**Step 4: 发送 MCP 文件系统请求**

```bash
curl -sN -X POST http://localhost:8000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "列出 /tmp 目录下的文件", "thread_id": "test-fs"}' \
  | head -20
```

Expected: 返回 `/tmp` 目录内容（可能为空目录列表，视系统而定）。

**Step 5: 验证纯对话不受影响**

```bash
curl -sN -X POST http://localhost:8000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "你好，介绍一下自己", "thread_id": "test-chat"}' \
  | head -10
```

Expected: 正常流式返回 AI 自我介绍，无工具调用。

**Step 6: 提交（若有调整）**

```bash
git add -p  # 只 stage 必要的调整
git commit -m "fix(backend/ch4): <描述调整内容>"
```

---

## 验收标准回顾

- [ ] `uv run pytest tests/test_tools.py -v` 全部通过
- [ ] 后端导入无报错
- [ ] 计算器请求返回正确数值
- [ ] MCP filesystem 请求返回 /tmp 文件列表
- [ ] 普通对话正常流式返回
